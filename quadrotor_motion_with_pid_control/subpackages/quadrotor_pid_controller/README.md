# Quadrotor PID controller

The ROS node "quadrotor PID controller" implements a motion controller for quadrotors that operates basically in the following way:

- The controller receives as input data motion references that establish the movement goal expressed as follows: the desired pose <x, y, z, yaw, pitch, roll> and the desired speed <d_x, d_y, d_z, d_yaw, d_pitch, d_roll>. The specific reference values that are used in a particular case depend on the control mode of the controller. For example, if the control mode is GROUND_SPEED the reference values used are <z, yaw, d_x, d_y> (and the rest of the references are discarded).

- As a result, the controller generates a periodic output at a high frequency for the multirotor actuators. This output is expressed with the following values <d_yaw, d_z, pitch, roll>.

This specification partially follows the recommendations established in [REP 147](http://www.ros.org/reps/rep-0147.html#rep105) for subscribed topics.

# Services

- **set_control_mode** ([aerostack_msgs/SetControlMode](https://bitbucket.org/visionaerialrobotics/aerostack_msgs/src/master/srv/SetControlMode.srv))  
This service establishes the control mode. The mode can be POSE, SPEED, GROUND_SPEED, SPEED_3D and ATTITUDE.

# Subscribed topics

- **motion_reference/pose** ([geometry_msgs/PoseStamped](http://docs.ros.org/api/geometry_msgs/html/msg/PoseStamped.html))  
Pose reference for the controller expressed as <x, y, z, yaw, pitch, roll>. If the control mode is POSE the controller uses the values <x, y, z, yaw> (the values for <pitch, roll> are discarded). If the control mode is SPEED the controller does not use any values of this message. If the control mode is GROUND_SPEED the controller only uses the values <z, yaw> (the values <x, y, pitch, roll> are discarded>. If the control mode is SPEED_3D the controller only uses the value <yaw> (the values <x, y, z, pitch, roll> are discarded). If the control mode is ATTITUDE the controller uses the values <z, yaw, pitch, roll> (the values for <x, y> are discarded).

- **motion_reference/speed** ([geometry_msgs/TwistStamped](http://docs.ros.org/lunar/api/geometry_msgs/html/msg/TwistStamped.html))  
Speed reference for the controller expressed as <d_x, d_y, d_z, d_yaw, d_pitch, d_roll>. If the control mode is SPEED the controller uses the values <d_x, d_y, d_z, d_yaw> (the values for <d_pitch, d_roll> are discarded). If the control mode is POSE the controller does not use any values of this message. If the control mode is GROUND_SPEED the controller uses the values <d_x, d_y> (the values for <d_z, d_yaw, d_pitch, d_roll> are discarded). If the control mode is SPEED_3D the controller uses the values <d_x, d_y, d_z> (the values for <d_yaw, d_pitch, d_roll> are discarded). If the control mode is ATTITUDE the controller the controller does not use any values of this message

- **self_localization/pose** ([geometry_msgs/PoseStamped](http://docs.ros.org/api/geometry_msgs/html/msg/PoseStamped.html))      
Current pose of the vehicle.

- **self_localization/speed** ([geometry_msgs/TwistStamped](http://docs.ros.org/lunar/api/geometry_msgs/html/msg/TwistStamped.html))     
Current speed of the vehicle.

# Published topics

- **actuator_command/roll_pitch** ([geometry_msgs/PoseStamped](http://docs.ros.org/api/geometry_msgs/html/msg/PoseStamped.html))           
Actuator command for the multirotor specifying roll and pitch (the rest of values for <x, y, z, yaw> are discarded).

- **actuator_command/altitude_rate_yaw_rate** ([geometry_msgs/TwistStamped](http://docs.ros.org/api/geometry_msgs/html/msg/TwistStamped.html))           
Actuator command for the multirotor specifying rates for altitude (d_z) and yaw (d_yaw) (the rest of values for <d_x, d_y, d_yaw, d_pitch, d_roll> are discarded).

- **motion_reference/assumed_control_mode** ([aerostack_msgs/MotionControlMode](https://bitbucket.org/visionaerialrobotics/aerostack_msgs/src/master/msg/MotionControlMode.msg))  
Current controller's control mode.

- **motion_reference/assumed_speed** ([geometry_msgs/TwistStamped](http://docs.ros.org/lunar/api/geometry_msgs/html/msg/TwistStamped.html))  
Speed reference assumed by the controller. The controller assumes different ground speed values depending on the control mode. When the mode is SPEED, the controller assumes the constant values <d_x, d_y, d_z, d_yaw> given as input for speed reference. Otherwise, the controller uses variable values for speed (for example, values that are generated by the own controller to reach a particular point).

## Deprecated published topics

- **command/dAltitude** ([droneMsgsROS/droneAltitudeCmd](https://bitbucket.org/joselusl/dronemsgsros/src/master/msg/droneAltitudeCmd.msg))  
Altitude command.

- **command/dYaw** ([droneMsgsROS/droneDYawCmd](https://bitbucket.org/joselusl/dronemsgsros/src/master/msg/droneDYawCmd.msg))  
Yaw command.

- **command/pitch_roll** ([droneMsgsROS/dronePitchRollCmd](https://bitbucket.org/joselusl/dronemsgsros/src/master/msg/dronePitchRollCmd.msg))  
Pitch and roll.

# Parameters

- **frequency** (double).        
The frequency of the controller in Hertz.

- **initial_control_mode** (string, allowed values {"pose", "speed"}, default: "pose").        
Initial control mode.

# Configuration file

The controller uses a configuration file in YAML format called `quadrotor_pid_controller_config.yaml` with parameters for four PID controllers: position, altitude, speed and yaw. Each PID controller has 3 gains:

* Proportional gain: this parameter is very important in a PID controller. The higher the gain the more the oscillations UAV about a given position. This gain parameter should be set a value where the UAV is not too sluggish or responsive at a desired position.

* Derivative gain: this parameter influences how fast the UAV can reach the desired value. Hence higher values tend to make the UAV more responsive, and also more inestable.

* Integral gain: this parameter makes the UAV maintain its desired setpoint position, that means that deletes the stationary error. That gain introduces delay and overshoot, so it should not be so big, in some case it is desirable not to use because of that. 

There are also both minimum and maximum limits (saturation), which set the maximum and minimum output of the control. And another parameter (anti wind-up) that describes the capability of recover from saturation. 

The controller needs to be tuned to change the flight behavior of the UAV (e.g., more aggressive flight) or a new UAV is used. In order to tune the controller, you should start tuning proportional gain, and continue adding a small amount on derivative, and if it necessary on integral. You can tune each controller independently, with the exception of position_controller, that is necessary to tune speed one previously.

This is an example of the content of the configuration file:

    position_x:
        proportional_gain:    1.00       
        derivative_gain:      0.20       
        integral_gain:        0.00        
        saturation_enabled:   true        
        saturation_min:      -2.0      
        saturation_max:       2.0     
        anti_wind_up_enabled: true    
        anti_wind_up:         0.5
    position_y:
        proportional_gain:    1.00       
        derivative_gain:      0.20       
        integral_gain:        0.00        
        saturation_enabled:   true        
        saturation_min:      -2.0      
        saturation_max:       2.0     
        anti_wind_up_enabled: true
        anti_wind_up:         0.5
    position_z:
        proportional_gain:    1.10       
        derivative_gain:      0.15       
        integral_gain:        0.40        
        saturation_enabled:   true        
        saturation_min:      -1.40      
        saturation_max:       1.40     
        anti_wind_up_enabled: true    
        anti_wind_up:         0.60
        feedforward_enabled:  false
        feedforward_mass:     0.73
        feedforward_factor:   0.36
    speed_x:
        proportional_gain:    0.30       
        derivative_gain:      0.03       
        integral_gain:        0.10        
        saturation_enabled:   true        
        saturation_min:      -0.50      
        saturation_max:       0.50     
        anti_wind_up_enabled: true    
        anti_wind_up:         0.60
    speed_y:
        proportional_gain:    0.30       
        derivative_gain:      0.03       
        integral_gain:        0.10        
        saturation_enabled:   true        
        saturation_min:      -0.50      
        saturation_max:       0.50     
        anti_wind_up_enabled: true    
        anti_wind_up:         0.60
        vxy_max_enabled:      true
        vxy_max:              2.0
    yaw:
        proportional_gain:    1.00       
        derivative_gain:      0.05       
        integral_gain:        0.40        
        saturation_enabled:   true        
        saturation_min:      -0.70      
        saturation_max:       0.70     
        anti_wind_up_enabled: true    
        anti_wind_up:         0.60

# Implementation notes

Next figure shows the structure used of PID controllers. In this figure, blue arrows represent input data, expressed in world coordinates (W). Output data is represented with brown arrows and use local coordinates (B). Green arrows represent feedback information. This structure of PID controllers is able to generate control outputs for position references <x, y, z, yaw> and ground speed references <dx, dy>.

![Image.jpg](https://bitbucket.org/repo/rokr9B/images/3087269297-Image.jpg)

The controller follows an algorithm that, at each iteration step, decides the values of control outputs by using the function getOutput(). This function uses other local functions getOutput() associated with local controllers (speed, position, yaw, altitude).

----
# Contributors

**Code maintainer:** Alberto Rodelgo

**Authors:** Pablo Santofimia (PID model and preliminary implementation), Alberto Rodelgo (programming and testing), Martin Molina (specification as a standard process)